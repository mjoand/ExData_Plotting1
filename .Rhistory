cachesolve(mami)
cacheSolve(mami)
cachesolve(mami)
caheSove(mami)
cacheSolve(mami)
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## The special "matrix" object returned by makeCacheMatrix is a list composed of 4
## functions:
## set:
## get: returns the matrix x, passed as an argument to the MakeCacheMatrix function
## setsolve:
## getsolve: returns either NULL, when MakeCacheMatrix is called for the first time,
##           or the inverse matrix if MakeCachematrix is called subsequently with
##           the same matrix x as argument
makeCacheMatrix <- function(x = matrix()){
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() x
setsolve <- function(inverse) {inv <<-inverse}
getsolve <- function() {inv}
list(set = set, get = get,setsolve = setsolve, getsolve = getsolve)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix
## If the inverse has already been calculated (and the matrix has not changed),
## cachesolve retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getsolve()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setsolve(inv)
inv
}
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## The special "matrix" object returned by makeCacheMatrix is a list composed of 4
## functions:
## set:
## get: returns the matrix x, passed as an argument to the MakeCacheMatrix function
## setinverse:
## getinverse: returns either NULL, when MakeCacheMatrix is called for the first time,
##           or the inverse matrix if MakeCachematrix is called subsequently with
##           the same matrix x as argument
makeCacheMatrix <- function(x = matrix()){
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {x}
setsolve <- function(inverse) {inv <<-inverse}
getsolve <- function() {inv}
list(set = set, get = get,setinverse = setinverse, getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix
## If the inverse has already been calculated (and the matrix has not changed),
# cachesolve retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
## retrieving inv (NULL if it is the first time MakeCacheMatrix has been called,
#
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
cacheSove(mami)
cacheSolve(mami)
mami
cache Solve(mami)
cacheSolve(mami)
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## The special "matrix" object returned by makeCacheMatrix is a list composed of 4
## functions:
## set:
## get: returns the matrix x, passed as an argument to the MakeCacheMatrix function
## setinverse:
## getinverse: returns either NULL, when MakeCacheMatrix is called for the first time,
#           or the inverse matrix if MakeCachematrix is called subsequently with
#           the same matrix x as argument
makeCacheMatrix <- function(x = matrix()){
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {x}
setinverse <- function(inverse) {inv <<-inverse}
getinverse <- function() {inv}
list(set = set, get = get,setinverse = setinverse, getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix
## If the inverse has already been calculated (and the matrix has not changed),
# cachesolve retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
## retrieving inv (NULL if it is the first time MakeCacheMatrix has been called,
#
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
cacheSolve(mami)
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## The special "matrix" object returned by makeCacheMatrix is a list composed of 4
## functions:
## set:
## get: returns the matrix x, passed as an argument to the MakeCacheMatrix function
## setinverse:
## getinverse: returns either NULL, when MakeCacheMatrix is called for the first time,
#           or the inverse matrix if MakeCachematrix is called subsequently with
#           the same matrix x as argument
makeCacheMatrix <- function(x = matrix()){
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {x}
setinverse <- function(inverse) {inv <<-inverse}
getinverse <- function() {inv}
list(set = set, get = get,setinverse = setinverse, getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix
## If the inverse has already been calculated (and the matrix has not changed),
# cachesolve retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
## retrieving inv (NULL if it is the first time MakeCacheMatrix has been called,
# the cached inverse matrix if MakeCacheMatrix has been previously called with
# the same matrix as argument
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
m<-c(1,2,3,4)
mam<-matrix(m,2,2)
mami<-makeCacheMatrix(mam)
mami
cacheSolve(mami)
cachesolve(mami)
cacheSolve(mami)
n<-c(3,0,0,4)
nan<-matrix(n,2,2)
nan
nani<-makeCacheMatrix(nan)
cacheSolve(nani)
cachesolve(mami)
cacheSolve(mami)
cachesolve(nani)
cacheSolve(nani)
q()
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## The special "matrix" object returned by makeCacheMatrix is a list composed of 4
## functions:
## set:
## get: returns the matrix x, passed as an argument to the MakeCacheMatrix function
## setinverse:
## getinverse: returns either NULL, when MakeCacheMatrix is called for the first time,
#           or the inverse matrix if MakeCachematrix is called subsequently with
#           the same matrix x as argument
makeCacheMatrixb <- function(x = matrix()){
inv <- NULL
get <- function() {x}
setinverse <- function(inverse) {inv <<-inverse}
getinverse <- function() {inv}
list(get = get,setinverse = setinverse, getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix
## If the inverse has already been calculated (and the matrix has not changed),
# cachesolve retrieves the inverse from the cache.
cacheSolveb <- function(x, ...) {
## retrieving inv (NULL if it is the first time the
# sequence cachesolve(MakeCacheMatrix) has been called,
# the cached inverse matrix if cachesolve(MakeCacheMatrix)
#has been previously called with the same matrix as argument
inv <- x$getinverse()
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
m<-c(1,2,3,4)
mam<-matrix(m,2,2)
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## The special "matrix" object returned by makeCacheMatrix is a list composed of 4
## functions:set, get, setinverse and getinverse
##
## get: caches the matrix x, passed as an argument to the MakeCacheMatrix function
## getinverse: returns NULL, when MakeCacheMatrix is called for the first time
# or if MakeCacheMatrix is called withou a subsequent call of the function cacheSolve,
# or caches the inverse of x when MakeCacheMatrix is called following a
#call from cacheSolve
makeCacheMatrix <- function(x = matrix()){
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {x}
setinverse <- function(inverse) {inv <<-inverse}
getinverse <- function() {inv}
list(set = set, get = get,setinverse = setinverse, getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix
## If the inverse has already been calculated (and the matrix has not changed),
# cachesolve retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
#verifying if the inverse matrix has been cached and returning it if that is the case
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
##If the inverse matrix has not been cached the original matrix x is retrieved from
# the cache function get, its inverse is computed and passed as an argument to
# the function set inverse to be cached
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## The special "matrix" object returned by makeCacheMatrix is a list composed of 4
## functions:set, get, setinverse and getinverse
##
## get: caches the matrix x, passed as an argument to the MakeCacheMatrix function
## getinverse: returns NULL, when MakeCacheMatrix is called for the first time
# or if MakeCacheMatrix is called withou a subsequent call of the function cacheSolve,
# or caches the inverse of x when MakeCacheMatrix is called following a
#call from cacheSolve
makeCacheMatrix <- function(x = matrix()){
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {x}
setinverse <- function(inverse) {inv <<-inverse}
getinverse <- function() {inv}
list(set = set, get = get,setinverse = setinverse, getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix
## If the inverse has already been calculated (and the matrix has not changed),
# cachesolve retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
#verifying if the inverse matrix has been cached and returning it if that is the case
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
##If the inverse matrix has not been cached the original matrix x is retrieved from
# the cache function get, its inverse is computed and passed as an argument to
# the function set inverse to be cached
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
## makeCacheMatrix creates a special "matrix" object that can cache its inverse.
## The special "matrix" object returned by makeCacheMatrix is a list composed of 4
## functions:set, get, setinverse and getinverse
##
## get: caches the matrix x, passed as an argument to the MakeCacheMatrix function
## getinverse: returns NULL, when MakeCacheMatrix is called for the first time
# or if MakeCacheMatrix is called withou a subsequent call of the function cacheSolve,
# or caches the inverse of x when MakeCacheMatrix is called following a
#call from cacheSolve
makeCacheMatrix <- function(x = matrix()){
inv <- NULL
set <- function(y) {
x <<- y
inv <<- NULL
}
get <- function() {x}
setinverse <- function(inverse) {inv <<-inverse}
getinverse <- function() {inv}
list(set = set, get = get,setinverse = setinverse, getinverse = getinverse)
}
## cacheSolve computes the inverse of the special "matrix" returned by makeCacheMatrix
## If the inverse has already been calculated (and the matrix has not changed),
# cachesolve retrieves the inverse from the cache.
cacheSolve <- function(x, ...) {
inv <- x$getinverse()
#verifying if the inverse matrix has been cached and returning it if that is the case
if(!is.null(inv)) {
message("getting cached data")
return(inv)
}
##If the inverse matrix has not been cached the original matrix x is retrieved from
# the cache function get, its inverse is computed and passed as an argument to
# the function set inverse so that it can be cached by getinverse in makeCacheMatrix
data <- x$get()
inv <- solve(data, ...)
x$setinverse(inv)
inv
}
m<-c(1,2,3,4)
mam<-matrix(m,2,2)
mami<-makeCacheMatrix(mam)
mami$set()
mami$get()
mami$getinverse()
mami$setinverse()
cacheSolve(mami)
mami$get()
mami$set()
mami$set
mami$getinverse()
mami$setinverse
mami$setineverse()
mami$setinverse()
mami$setinverse(x)
mami$setinverse(mam)
z<-mami$setinverse(mam)
z
cacheSolve(mami)
q()
? seed
?seed
? set.seed
q()
? is.element
x<-2
y<-c(2,3,4,2)
is.element(x,y)
y<-c(1,2,2,2,2)
is.element(x,y)
q()
?setInternet2
?setInternet2
setInternet2(TRUE)
download.file(https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv)
?dowloadfile
?downloadfile
?download.file
library(RCurl)
x <- getURL("https://raw.github.com/aronlindberg/latent_growth_classes/master/LGC_data.csv")
y <- read.csv(text = x)
x<-getURL(https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv)
x<-getURL(https:/d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv)
x<-getURL(https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv)
getwd()
x<-getURL(http:/d396qusza40orc.cloudfront.net/getdata%2Fdata%2Fss06hid.csv)
?fread
install.package(data.table)
install.packages("data.table")
library(data.table)
?fread
library(xlsl)
library(xlsx)
q()
q()
install.packages(sqldf)
?install.packages
library(sqldf)
q()
library(sqldf)
q()
?RTools
url<-"http://scholar.google.com/citations?user=HI-I6C0AAAAJ"
con=url("http://scholar.google.com/citations?user=HI-I6C0AAAAJ")
htmlCode=readLines(con)
close(con)
htmlCode
library(httr)
?sign_oauth1.0
myapp=oauth_app("github",key="5b7bc3329c3b17f0033f",secret="20fdfa746b3259e62410f5b7c2631ff479987ba9")
sig=sign_oauth1.0(myapp,token="5aa94183ea41258d6062a5058f0fb14c50d669c8")
puta=GET("https://api.github.com/users/jtleek/repos",sig)
install.packages("jsonlite")
library(jsonlite)
json1=content(puta)
json2=jsonlite::fromJSON(toJSON(json1))
json2
json1
q()
library(http)
library(httr)
? oauth2.0_token
oauth_endpoints("github")
myapp <- oauth_app("github", "dc20ab113f2eb30d2b66")
myapp <- oauth_app("github", "dc20ab113f2eb30d2b66","564c7e23e3f76deefbbe2aae9b3fc0581192750")
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
install.packages("httpuv")
library(httpuv)
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
library(jsonlite)
jsonData<-fromJSON("https://api.github.com/users/jtleek/repos")
names(jsonData)
sort(names(jsonData))
class(jsonData)
class(jsonData)
JsonData$owner
jsondata$owner
jsonData$owner
jsonData$id
names(jsonData)
jsonData$created_at
jsonData$full_name
q()
? analysis
q()
?reshape
?colMean
?cMean
?cMeans
colMeans
?colMeans
v<-c("a","b","c")
df<-data.frame(v,v,v,v)
colMeans(df)
df
subset(df,v=="a")
subset(df,v %in% c("a","b")[,2:4]
Q
subset(df,v %in% c("a","b"))[,2:4]
c(1,"jo",subset(df,v %in% c("a","b"))[,3])
?file.path
dir()
q()
q()
windows()
windows()
postscrpt()
postscript()
xfig()
?xfig
?windows
?postscript
?par
?pch
?quartz
?quartz
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
install.packages("graphics")
library(graphics)
?quartz
??quartz
install.packages("grDevices")
install.packages("grDevices")
library(grDevices)
?quartz
?transform
colors()
dev.cur()
windows()
windows()
dev,cur()
dev.cur()
dev.cur()
windows()
dev.cur()
dev.set(1)
windows()
dev.cur()
dev.set(3)
q()
?r
?ggm
?rgm
x<-rnorm(100)
hist(x)
cur.dev()
dev.cur()
dev.set(1)
dev.set(2)
dev.cur()
q()
?lty
?par
setwd("C:/Users/mja/Desktop/DataScience/ExploratoryDataAnalysis/ProjectI/ExData_Plotting1")
dir()
source("plot3.R")
dir()
source("plot3.R")
dir()
?plot
?par
source("plot4.R")
dir()
source("plot4.R")
dir()
source("plot3.R")
source("plot3.R")
